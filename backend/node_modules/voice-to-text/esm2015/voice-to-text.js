import { Injectable, NgZone, Component, Input, Output, EventEmitter, NgModule } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SpeechRecognitionService {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        this.stop = () => {
            this.speechRecognition.stop();
        };
    }
    /**
     * @return {?}
     */
    record() {
        return Observable.create(observer => {
            const { webkitSpeechRecognition } = /** @type {?} */ (window);
            this.speechRecognition = new webkitSpeechRecognition();
            this.speechRecognition.continuous = true;
            this.speechRecognition.lang = 'en-us';
            this.speechRecognition.maxAlternatives = 1;
            this.speechRecognition.onresult = speech => {
                let /** @type {?} */ term = '';
                if (speech.results) {
                    const /** @type {?} */ result = speech.results[speech.resultIndex];
                    const /** @type {?} */ transcript = result[0].transcript;
                    if (result.isFinal) {
                        if (result[0].confidence < 0.3) {
                            console.log('Unrecognized result - Please try again');
                        }
                        else {
                            term = transcript;
                        }
                    }
                }
                this.zone.run(() => {
                    observer.next(term);
                });
            };
            this.speechRecognition.onerror = error => {
                observer.error(error);
            };
            this.speechRecognition.onend = () => {
                observer.complete();
            };
            this.speechRecognition.start();
        });
    }
}
SpeechRecognitionService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
SpeechRecognitionService.ctorParameters = () => [
    { type: NgZone, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class InputComponent {
    /**
     * @param {?} speech
     */
    constructor(speech) {
        this.speech = speech;
        this.search_text = '';
        this.blink = false;
        this.spokenText = new EventEmitter();
        this.error = new EventEmitter();
        this.showInput = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    triggerMike() {
        if (!('webkitSpeechRecognition' in window)) {
            console.log('please upgrade');
        }
        else {
            this.search_text = '';
            this.blink = true;
            this.search();
        }
    }
    /**
     * @return {?}
     */
    search() {
        this.speech.record().subscribe((text) => {
            this.search_text = text;
            this.blink = false;
            this.spokenText.emit(this.search_text);
            this.speech.stop();
        }, (err) => {
            this.error.emit('Failed in Fetching');
            if (err.error === 'no-speech') {
                this.search();
            }
        });
    }
}
InputComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-input',
                template: `<div>
  <ng-content></ng-content>
  <div
    class="boxHolder"
  >
    <input
      *ngIf="showInput"
      [(ngModel)]="search_text"
      class="inputBox"
      autofocus
    />
    <div
      [ngClass]="showInput ? 'indicator' : 'floatingIndicator'"
    >
      <img
        class="mike"
        (click)="triggerMike()"
        src="assets/mike.png"
      />
      <div class="spinner" *ngIf="blink"></div>
    </div>
  </div>
</div>
`,
                styles: [`@-webkit-keyframes spin{from{opacity:0}to{opacity:.9}}@keyframes spin{from{opacity:0}to{opacity:.9}}.spinner{width:25px;height:25px;border-radius:100%;background-color:red;-webkit-animation-name:spin;animation-name:spin;-webkit-animation-duration:2s;animation-duration:2s;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;-webkit-animation-timing-function:linear;animation-timing-function:linear}.inputBox{height:35px;line-height:25px;padding:5px;border-radius:4px;border:1px solid #d8d8d8;display:inline-block;width:95%;font-size:1rem}.boxHolder{position:relative}.indicator{position:absolute;top:10px;right:60px;display:-webkit-box;display:-ms-flexbox;display:flex}.indicator>.mike{width:20px;height:20px;position:relative}.indicator>.spinner{position:absolute;top:-1px;right:-3px}.floatingIndicator>.mike{width:20px;height:20px;position:relative}.floatingIndicator>.spinner{position:absolute;top:-1px;left:-3px}`]
            },] },
];
/** @nocollapse */
InputComponent.ctorParameters = () => [
    { type: SpeechRecognitionService, },
];
InputComponent.propDecorators = {
    "spokenText": [{ type: Output },],
    "error": [{ type: Output },],
    "showInput": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class InputModule {
}
InputModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                declarations: [InputComponent],
                exports: [InputComponent],
                providers: [
                    SpeechRecognitionService
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { InputModule, InputComponent as ɵa, SpeechRecognitionService as ɵb };
//# sourceMappingURL=voice-to-text.js.map
